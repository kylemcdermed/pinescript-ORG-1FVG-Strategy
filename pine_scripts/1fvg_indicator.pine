//@version=5 
strategy("NQ1! 1m Liquidity + 1FVG Strategy", overlay=true, margin_long=100, margin_short=100)

// Force 1-minute timeframe only
if timeframe.period != "1"
    runtime.error("This strategy ONLY works on 1-minute charts. Switch to 1m timeframe.")

//------------------------------------------------------------------------------
//BUY SIDE AND SELL SIDE LIQUIDITY CODE
//-----------------------------------------------------------------------------{

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
liqGrp = 'Liquidity Detection'
liqLen = input.int   (7, title = 'Detection Length', minval = 3, maxval = 13, inline = 'LIQ', group = liqGrp)
liqMar = 10 / input.float (6.9, 'Margin', minval = 4, maxval = 9, step = 0.1, inline = 'LIQ', group = liqGrp)

liqBuy = input.bool (true, 'Buyside Liquidity Zones, Margin', inline = 'Buyside', group = liqGrp)
marBuy    = input.float(2.3, '', minval = 1.5, maxval = 10, step = .1, inline = 'Buyside', group = liqGrp)
cLIQ_B = input.color (color.new(#4934eb,  0), '', inline = 'Buyside', group = liqGrp)

liqSel = input.bool (true, 'Sellside Liquidity Zones, Margin', inline = 'Sellside', group = liqGrp)
marSel = input.float(2.3, '', minval = 1.5, maxval = 10, step = .1, inline = 'Sellside', group = liqGrp)
cLIQ_S = input.color (color.new(#eb3434,  0), '', inline = 'Sellside', group = liqGrp)

lqVoid = input.bool (false, 'Liquidity Voids, Bullish', inline = 'void', group = liqGrp)
cLQV_B = input.color (color.new(#4934eb,  0), '', inline = 'void', group = liqGrp)
cLQV_S = input.color (color.new(#eb3434,  0), 'Bearish', inline = 'void', group = liqGrp)
lqText = input.bool (false, 'Label', inline = 'void', group = liqGrp)

mode   = input.string('Historical', title = 'Mode', options =['Present', 'Historical'], inline = 'MOD', group = liqGrp)
visLiq = input.int   (500, '    # Visible Levels', minval = 1, maxval = 1000, inline = 'MOD', group = liqGrp)

// TRADING TIME SETTINGS
tradingGrp = 'Trading Hours'
start_hour = input.int(9, "Start Hour", minval=0, maxval=23, group=tradingGrp)
start_minute = input.int(30, "Start Minute", minval=0, maxval=59, group=tradingGrp)
end_hour = input.int(12, "End Hour", minval=0, maxval=23, group=tradingGrp)
end_minute = input.int(0, "End Minute", minval=0, maxval=59, group=tradingGrp)

//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
maxSize = 500 // Increased for more historical data
atr     = ta.atr(10)
atr200  = ta.atr(200)
per     = true  

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ 
    int   [] d 
    int   [] x 
    float [] y 

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    int   i = bar_index

type liq
    box   bx 
    box   bxz
    box   bxt
    bool  brZ 
    bool  brL 
    line  ln
    line  lne

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var ZZ aZZ = ZZ.new(
 array.new <int>  (maxSize,  0), 
 array.new <int>  (maxSize,  0), 
 array.new <float>(maxSize, na)
 )

bar b = bar.new()

var liq[] b_liq_B = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))
var liq[] b_liq_S = array.new<liq> (1, liq.new(box(na), box(na), box(na), false, false, line(na), line(na)))

var b_liq_V = array.new_box()

var int dir = na, var int x1 = na, var float y1 = na, var int x2 = na, var float y2 = na

//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
method in_out(ZZ aZZ, int _d, int _x, float _y) =>
    aZZ.d.unshift(_d), aZZ.x.unshift(_x), aZZ.y.unshift(_y), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop()

max_bars_back(time, 2000)

//-----------------------------------------------------------------------------}
//Liquidity Calculations - SHOW BSL/SSL LINES
//-----------------------------------------------------------------------------{
x2 := b.i - 1 
ph  = ta.pivothigh(liqLen, 1) 
pl  = ta.pivotlow (liqLen, 1) 

if ph   
    dir := aZZ.d.get(0) 
    x1  := aZZ.x.get(0) 
    y1  := aZZ.y.get(0) 
    y2  := nz(b.h[1]) 

    if dir < 1 
        aZZ.in_out(1, x2, y2)
    else 
        if dir == 1 and ph > y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0 
        st_P  = 0. 
        st_B  = 0 
        minP  = 0. 
        maxP  = 10e6 

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) ==  1 
                if aZZ.y.get(i) > ph + (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > ph - (atr / liqMar) and aZZ.y.get(i) < ph + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i) 
                        st_P := aZZ.y.get(i) 
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_B.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_B.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)), 
                   box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = 'Buyside liquidity', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_bottom, text_color = color.new(cLIQ_B, 25), bgcolor = color(na), border_color = color(na)),
                   false, 
                   false,
                   line.new(st_B, st_P, bar_index + 50, st_P, color = color.new(cLIQ_B, 0), extend = extend.right),
                   line.new(bar_index, st_P, bar_index + 200, st_P, color = color.new(cLIQ_B, 0), style = line.style_dotted, extend = extend.right))
                 )

            if b_liq_B.size() > visLiq
                getLast = b_liq_B.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()
                getLast.lne.delete()               

if pl
    dir := aZZ.d.get (0)  
    x1  := aZZ.x.get (0) 
    y1  := aZZ.y.get (0)  
    y2  := nz(b.l[1]) 
    
    if dir > -1
        aZZ.in_out(-1, x2, y2)
    else
        if dir == -1 and pl < y1 
            aZZ.x.set(0, x2), aZZ.y.set(0, y2)
    
    if per
        count = 0
        st_P  = 0.
        st_B  = 0
        minP  = 0.
        maxP  = 10e6

        for i = 0 to maxSize - 1
            if aZZ.d.get(i) == -1 
                if aZZ.y.get(i) < pl - (atr / liqMar)
                    break
                else
                    if aZZ.y.get(i) > pl - (atr / liqMar) and aZZ.y.get(i) < pl + (atr / liqMar)
                        count += 1
                        st_B := aZZ.x.get(i)
                        st_P := aZZ.y.get(i)
                        if aZZ.y.get(i) > minP
                            minP := aZZ.y.get(i)
                        if aZZ.y.get(i) < maxP 
                            maxP := aZZ.y.get(i)

        if count > 2
            getB = b_liq_S.get(0)

            if st_B == getB.bx.get_left()
                getB.bx.set_top(math.avg(minP, maxP) + (atr / liqMar))
                getB.bx.set_rightbottom(b.i + 10, math.avg(minP, maxP) - (atr / liqMar))
            else
                b_liq_S.unshift(
                 liq.new(
                   box.new(st_B, math.avg(minP, maxP) + (atr / liqMar), b.i + 10, math.avg(minP, maxP) - (atr / liqMar), bgcolor=color(na), border_color=color(na)),
                   box.new(na, na, na, na, bgcolor=color(na), border_color=color(na)),
                   box.new(st_B, st_P, b.i + 10, st_P, text = 'Sellside liquidity', text_size = size.tiny, text_halign = text.align_left, text_valign = text.align_top, text_color = color.new(cLIQ_S, 25), bgcolor=color(na), border_color=color(na)),
                   false,
                   false,
                   line.new(st_B, st_P, bar_index + 50, st_P, color = color.new(cLIQ_S, 0), extend = extend.right),
                   line.new(bar_index, st_P, bar_index + 200, st_P, color = color.new(cLIQ_S, 0), style = line.style_dotted, extend = extend.right))
                 )  

            if b_liq_S.size() > visLiq
                getLast = b_liq_S.pop()
                getLast.bx.delete()
                getLast.bxz.delete()
                getLast.bxt.delete()
                getLast.ln.delete()            
                getLast.lne.delete()               

// Update liquidity breach tracking
for i = 0 to b_liq_B.size() - 1
    x = b_liq_B.get(i)
    
    if not x.brL
        x.lne.set_x2(b.i)

        if b.h > x.bx.get_top()
            x.brL := true
            x.brZ := true
            x.bxz.set_lefttop(b.i - 1, math.min(x.ln.get_y1() + marBuy * (atr), b.h))
            x.bxz.set_rightbottom(b.i + 1, x.ln.get_y1())
            x.bxz.set_bgcolor(color.new(cLIQ_B, liqBuy ? 73 : 100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marBuy * (atr) and b.h < x.ln.get_y1() + marBuy * (atr)
            x.bxz.set_right(b.i + 1)
            x.bxz.set_top(math.max(b.h, x.bxz.get_top()))
            if liqBuy
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false

for i = 0 to b_liq_S.size() - 1
    x = b_liq_S.get(i)

    if not x.brL
        x.lne.set_x2(b.i)

        if b.l < x.bx.get_bottom()
            x.brL := true
            x.brZ := true
            x.bxz.set_lefttop(b.i - 1, x.ln.get_y1())
            x.bxz.set_rightbottom(b.i + 1, math.max(x.ln.get_y1() - marSel * (atr), b.l))
            x.bxz.set_bgcolor(color.new(cLIQ_S, liqSel ? 73 : 100))

    else if x.brZ
        if b.l > x.ln.get_y1() - marSel * (atr) and b.h < x.ln.get_y1() + marSel * (atr)
            x.bxz.set_rightbottom(b.i + 1, math.min(b.l, x.bxz.get_bottom()))
            if liqSel
                x.lne.set_x2(b.i + 1)
        else
            x.brZ := false

//------------------------------------------------------------------------------
//1FVG DETECTION AND DISPLAY
//-----------------------------------------------------------------------------{

// Function to detect 1FVG
get1mFVG() =>
    float fvg_top = na
    float fvg_bottom = na
    float fvg_high_c1 = na
    float fvg_low_c1 = na
    float fvg_high_c3 = na
    float fvg_low_c3 = na
    bool is_bullish_fvg = false
    bool is_bearish_fvg = false
    
    if low > high[2]
        is_bullish_fvg := true
        fvg_bottom := high[2]  
        fvg_top := low         
        fvg_high_c1 := high    
        fvg_low_c1 := low      
        fvg_high_c3 := high[2] 
        fvg_low_c3 := low[2]   
    
    if high < low[2]
        is_bearish_fvg := true
        fvg_top := low[2]      
        fvg_bottom := high     
        fvg_high_c1 := high    
        fvg_low_c1 := low      
        fvg_high_c3 := high[2] 
        fvg_low_c3 := low[2]   
    
    [fvg_top, fvg_bottom, fvg_high_c1, fvg_low_c1, fvg_high_c3, fvg_low_c3, is_bullish_fvg, is_bearish_fvg]

// Draw ALL FVGs with extend
[fvg_top, fvg_bottom, c1_high, c1_low, c3_high, c3_low, is_bull, is_bear] = get1mFVG()

if not na(fvg_top) and not na(fvg_bottom)
    line.new(bar_index, fvg_top, bar_index + 30, fvg_top, color=color.green, width=1, extend = extend.right)
    line.new(bar_index, fvg_bottom, bar_index + 30, fvg_bottom, color=color.red, width=1, extend = extend.right)
    box.new(bar_index, fvg_top, bar_index + 30, fvg_bottom, bgcolor=color.new(color.blue, 90), border_color=color.blue)

//------------------------------------------------------------------------------
//TRADING LOGIC - 1 MINUTE ONLY
//-----------------------------------------------------------------------------{

is_market_session = time(timeframe.period, "0930-1615", "America/New_York")
is_after_930 = hour(time, "America/New_York") >= 9 and minute(time, "America/New_York") >= 30

// TRADING WINDOW - Only trade between user-defined hours
current_hour = hour(time, "America/New_York")
current_minute = minute(time, "America/New_York")
trading_window = (current_hour > start_hour or (current_hour == start_hour and current_minute >= start_minute)) and 
                 (current_hour < end_hour or (current_hour == end_hour and current_minute <= end_minute))

session_change = ta.change(time("D"))

var bool session_started = false
var bool first_fvg_found = false
var bool sellside_swept_first = false
var bool buyside_swept_first = false
var bool looking_for_long = false
var bool looking_for_short = false
var bool trade_taken_today = false  // NEW: Only one trade per day

var float first_fvg_top = na
var float first_fvg_bottom = na
var float first_fvg_c1_high = na
var float first_fvg_c1_low = na  
var float first_fvg_c3_high = na
var float first_fvg_c3_low = na

// Session reset
if session_change
    session_started := false
    first_fvg_found := false
    sellside_swept_first := false
    buyside_swept_first := false
    looking_for_long := false
    looking_for_short := false
    trade_taken_today := false  // RESET: Allow one trade per new day
    first_fvg_top := na
    first_fvg_bottom := na
    first_fvg_c1_high := na
    first_fvg_c1_low := na
    first_fvg_c3_high := na
    first_fvg_c3_low := na

if is_market_session and not session_started
    session_started := true

// Find first FVG after 9:30
if session_started and not first_fvg_found and is_after_930
    if not na(fvg_top) and not na(fvg_bottom)
        first_fvg_found := true
        first_fvg_top := fvg_top
        first_fvg_bottom := fvg_bottom
        first_fvg_c1_high := c1_high
        first_fvg_c1_low := c1_low
        first_fvg_c3_high := c3_high
        first_fvg_c3_low := c3_low

// Check for liquidity sweeps
if session_started and is_after_930 and not sellside_swept_first and not buyside_swept_first
    
    // Check sellside sweep
    if b_liq_S.size() > 0
        for i = 0 to b_liq_S.size() - 1
            if b_liq_S.get(i).brL
                sellside_swept_first := true
                looking_for_long := true
                break
    
    // Check buyside sweep
    if b_liq_B.size() > 0 and not sellside_swept_first
        for i = 0 to b_liq_B.size() - 1
            if b_liq_B.get(i).brL
                buyside_swept_first := true
                looking_for_short := true
                break

// ENTRIES - Only during trading window and only one trade per day
if looking_for_long and first_fvg_found and strategy.position_size == 0 and trading_window and not trade_taken_today
    if close > first_fvg_c1_low
        strategy.entry("Long", strategy.long, qty=1)
        strategy.exit("Long Exit", "Long", stop=first_fvg_c3_low)
        trade_taken_today := true  // Mark trade as taken

if looking_for_short and first_fvg_found and strategy.position_size == 0 and trading_window and not trade_taken_today
    if close < first_fvg_c3_high
        strategy.entry("Short", strategy.short, qty=1)
        strategy.exit("Short Exit", "Short", stop=first_fvg_c1_high)
        trade_taken_today := true  // Mark trade as taken

// PROFIT TAKING - Let trades run to opposing liquidity
if strategy.position_size > 0 and not trade_taken_today
    // Look for buyside liquidity hit for profit taking
    if b_liq_B.size() > 0
        for i = 0 to b_liq_B.size() - 1
            liq_level = b_liq_B.get(i)
            if high >= liq_level.ln.get_y1()
                strategy.close("Long", comment="Profit at BSL")
                break

if strategy.position_size < 0 and not trade_taken_today
    // Look for sellside liquidity hit for profit taking
    if b_liq_S.size() > 0
        for i = 0 to b_liq_S.size() - 1
            liq_level = b_liq_S.get(i)
            if low <= liq_level.ln.get_y1()
                strategy.close("Short", comment="Profit at SSL")
                break
